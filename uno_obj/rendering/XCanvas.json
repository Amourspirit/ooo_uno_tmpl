{
  "id": "uno-ooo-parser",
  "version": "0.1.3",
  "timestamp": "2021-12-17 11:17:34+00:00",
  "name": "XCanvas",
  "type": "interface",
  "namespace": "com.sun.star.rendering",
  "parser_args": {
    "sort": true
  },
  "writer_args": {},
  "data": {
    "from_imports": [
      [
        "......x_mapping2_d",
        "XMapping2D"
      ]
    ],
    "from_imports_typing": [],
    "name": "XCanvas",
    "imports": [
      "XMapping2D"
    ],
    "namespace": "com.sun.star.rendering",
    "extends": [
      "XMapping2D"
    ],
    "desc": [
      "Central interface for rendering.",
      "",
      "This is the central interface for graphical output production, and the place where all draw methods are located.",
      "",
      "Some notes are in order to explain the concepts used here. The XCanvas interface is free of client-modifiable state, i.e. it can be used safely and without external synchronization in a multi-threaded environment. On the other hand, this implies that for nearly every canvas operation, external state is required. This is provided by ViewState and RenderState in a unified fashion, supplemented by a few extra state parameters for some methods (e.g. textured polygons or text rendering).",
      "",
      "When used careless, this scheme can be inefficient to some extend, because internally, view, render and other states have to be combined before rendering. This is especially expensive for complex clip polygons, i.e. when both ViewState and RenderState have a complex clip polygon set, which have to be intersected before rendering. It is therefore recommended to combine ViewState and RenderState already at the client side, when objects are organized in a hierarchical way: the classic example are grouped draw shapes, whose parent group object imposes a common clipping and a common transformation on its siblings. The group object would therefore merge the ViewState and the RenderState it is called with into a new ViewState, and call its siblings with a RenderState containing only the local offset (and no extra clipping).",
      "",
      "Further on, this stateless nature provides easy ways for caching. Every non-trivial operation on XCanvas can return a cache object, which, when called to redraw, renders the primitive usually much more quickly than the original method. Note that such caching is a lot more complicated, should the actual rendering a method yields depend on internal state (which is the case e.g. for the com.sun.star.awt.XGraphics interface). Please note, though, that deciding whether to return an XCachedPrimitive is completely up to the implementation - don't rely on the methods returning something (this is because there might be cases when returning such a cache object will actually be a pessimization, since it involves memory allocation and comparisons).",
      "",
      "Things that need more than a small, fixed amount of data are encapsulated in own interfaces, e.g. polygons and bitmaps. You can, in principle, roll your own implementations of these interfaces, wrap it around your internal representation of polygons and bitmaps, and render them. It might just not be overly fast, because the XCanvas would need to convert for each render call. It is therefore recommended to create such objects via the XGraphicDevice factory (to be retrieved from every canvas object via the getDevice() call) - they will then internally optimize to the underlying graphics subsystem.",
      "",
      "**See Also**",
      "",
      "    OOo 2.0"
    ],
    "url": "https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1rendering_1_1XCanvas.html",
    "items": {}
  }
}