{
  "id": "uno-ooo-parser",
  "version": "0.1.10",
  "timestamp": "2022-01-01 16:42:49+00:00",
  "name": "XTextLayout",
  "type": "interface",
  "namespace": "com.sun.star.rendering",
  "parser_args": {
    "sort": true
  },
  "writer_args": {
    "include_desc": true
  },
  "data": {
    "from_imports": [
      [
        "..uno.x_interface",
        "XInterface"
      ]
    ],
    "from_imports_typing": [
      [
        "..geometry.real_point2_d",
        "RealPoint2D"
      ],
      [
        ".x_canvas_font",
        "XCanvasFont"
      ],
      [
        ".string_context",
        "StringContext"
      ],
      [
        ".caret",
        "Caret"
      ],
      [
        ".x_text_layout",
        "XTextLayout"
      ],
      [
        "..geometry.real_rectangle2_d",
        "RealRectangle2D"
      ],
      [
        ".x_poly_polygon2_d",
        "XPolyPolygon2D"
      ],
      [
        ".text_hit",
        "TextHit"
      ],
      [
        ".x_poly_polygon2_d",
        "XPolyPolygon2D"
      ]
    ],
    "quote": [
      "TextHit",
      "typing.List[XTextLayout]",
      "XCanvasFont",
      "typing.List[float]",
      "RealPoint2D",
      "typing.List[RealRectangle2D]",
      "typing.List[XPolyPolygon2D]",
      "XPolyPolygon2D",
      "StringContext",
      "Caret",
      "RealRectangle2D"
    ],
    "typings": [
      "typing.List[XPolyPolygon2D]",
      "typing.List[XTextLayout]",
      "typing.List[RealRectangle2D]",
      "typing.List[float]"
    ],
    "requires_typing": true,
    "name": "XTextLayout",
    "imports": [],
    "namespace": "com.sun.star.rendering",
    "extends": [
      "com.sun.star.uno.XInterface"
    ],
    "desc": [
      "This is the central interface for text layouting.",
      "",
      "This is the central interface for text-related tasks more complicated than simple string rendering. Note that all query methods are subject to the current layout state of this object. That is, calls to XTextLayout.justify() or XTextLayout.applyLogicalAdvancements() are likely to change subsequent output of those query methods.",
      "",
      "Similar to XCanvasFont, all measurements and coordinates accepted and returned by this interface are relative to the font's local coordinate system (which only equals device coordinate space, if the combined render transformation used during text output is the identity transformation). Conversely, if the combined transformation used during text output is not the identity transformation, all measurements returned by this interface should be subjected to that transformation, to yield values in device coordinate space. Depending on the underlying font technology, actual device output might be off by up to one device pixel from the transformed metrics.",
      "",
      "**since**",
      "",
      "    OOo 2.0"
    ],
    "url": "https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1rendering_1_1XTextLayout.html",
    "items": {
      "methods": [
        {
          "name": "applyLogicalAdvancements",
          "returns": "None",
          "desc": [
            "Apply explicit advancements for every character in the layout string.",
            "",
            "This method applies the specified advancements to every logical character in the input string (not for every glyph. There might be multiple glyphs per input character, or multiple input characters per glyph). This is useful to explicitly manipulate the exact output positions of characters, e.g. relative to a reference output device."
          ],
          "raises": [
            "com.sun.star.lang.IllegalArgumentException"
          ],
          "args": [
            [
              "aAdvancements",
              "typing.List[float]",
              "in"
            ]
          ]
        },
        {
          "name": "combinedJustify",
          "returns": "float",
          "desc": [
            "Justify a number of text layouts to the given size.",
            "",
            "This method can be used to combine the layout of a text line into a single justification run. This is e.g. useful if the line consists of several text portions (e.g. because of different fonts or colors), but it is desirable to spread the available space more globally across the different layout objects. If, for example, one layout object contains significantly more whitespace or Kashidas than the rest, this method can assign proportionally more space to this layout object."
          ],
          "raises": [
            "com.sun.star.lang.IllegalArgumentException"
          ],
          "args": [
            [
              "aNextLayouts",
              "typing.List[XTextLayout]",
              "in"
            ],
            [
              "nSize",
              "float",
              "in"
            ]
          ]
        },
        {
          "name": "getBaselineOffset",
          "returns": "float",
          "desc": [
            "This method yields the baseline offset.",
            "",
            "This method returns the baseline offset for this layout object, either measured from the top or the left edge, depending on the writing direction (horizontally or vertically). Since rendering this layout via XCanvas.drawTextLayout() outputs relative to the layout object's baseline, this method can be used to e.g. output relative to the left, top edge."
          ],
          "raises": [],
          "args": []
        },
        {
          "name": "getCaret",
          "returns": "Caret",
          "desc": [
            "This method converts an insertion index to a caret.",
            "",
            "This method generates caret information for a given insertion point in the layout text."
          ],
          "raises": [
            "com.sun.star.lang.IndexOutOfBoundsException"
          ],
          "args": [
            [
              "nInsertionIndex",
              "int",
              "in"
            ],
            [
              "bExcludeLigatures",
              "bool",
              "in"
            ]
          ]
        },
        {
          "name": "getFont",
          "returns": "XCanvasFont",
          "desc": [
            "Request the associated font for this layout."
          ],
          "raises": [],
          "args": []
        },
        {
          "name": "getMainTextDirection",
          "returns": "int",
          "desc": [
            "This method returns the main writing direction.",
            "",
            "This method returns the main writing direction of this layout, i.e. either LEFT_TO_RIGHT or RIGHT_TO_LEFT."
          ],
          "raises": [],
          "args": []
        },
        {
          "name": "getNextInsertionIndex",
          "returns": "int",
          "desc": [
            "This method calculates a new insertion index.",
            "",
            "This method calculates a new insertion index, given a start index and the number of characters to skip. This is most useful for caret traveling."
          ],
          "raises": [
            "com.sun.star.lang.IndexOutOfBoundsException"
          ],
          "args": [
            [
              "nStartIndex",
              "int",
              "in"
            ],
            [
              "nCaretAdvancement",
              "int",
              "in"
            ],
            [
              "bExcludeLigatures",
              "bool",
              "in"
            ]
          ]
        },
        {
          "name": "getText",
          "returns": "StringContext",
          "desc": [
            "Request the text this layout contains."
          ],
          "raises": [],
          "args": []
        },
        {
          "name": "getTextHit",
          "returns": "TextHit",
          "desc": [
            "This method determines the hit position in the text.",
            "",
            "This method determines the index of the character hit at the specified position (in font coordinate space)."
          ],
          "raises": [],
          "args": [
            [
              "aHitPoint",
              "RealPoint2D",
              "in"
            ]
          ]
        },
        {
          "name": "justify",
          "returns": "float",
          "desc": [
            "Justify the text to the given size.",
            "",
            "This method is the core of the XTextLayout interface, because it layouts the text in a typographically correct way into the available space."
          ],
          "raises": [
            "com.sun.star.lang.IllegalArgumentException"
          ],
          "args": [
            [
              "nSize",
              "float",
              "in"
            ]
          ]
        },
        {
          "name": "queryInkMeasures",
          "returns": "typing.List[RealRectangle2D]",
          "desc": [
            "Query the ink bounding boxes for every glyph in the layouted text.",
            "",
            "Ink, or tight bounding boxes in this case means that for e.g. an \\\"a\\\", the bounding box for the XPolyPolygon2D describing the glyph \\\"a\\\" is returned, not the logical dimensions of the character in the font."
          ],
          "raises": [],
          "args": []
        },
        {
          "name": "queryLogicalAdvancements",
          "returns": "typing.List[float]",
          "desc": [
            "Query the advancements for every character in the input string.",
            "",
            "This method returns a sequence of advancements, one for each character in the input string (not for every glyph. There might be multiple glyphs per input character, or multiple input characters per glyph).",
            "",
            "An advancement value is the distance of the glyph to the beginning edge, which is left for LTR text and is right for RTL text. The maximum of the advancements can be deemed as the width of the whole text layout.",
            "",
            "This method can be used to query for the layout's default advancements, which can subsequently be changed and applied to the layout via XTextLayout.applyLogicalAdvancements()."
          ],
          "raises": [],
          "args": []
        },
        {
          "name": "queryLogicalHighlighting",
          "returns": "XPolyPolygon2D",
          "desc": [
            "This method generates a highlight polygon.",
            "",
            "This method generates a highlighting polygon from two insertion indices. This polygon will not always be visually continuous, if e.g. the text direction changes in the middle of the selection, the might be parts visually between start and end position that are not selected."
          ],
          "raises": [
            "com.sun.star.lang.IndexOutOfBoundsException"
          ],
          "args": [
            [
              "nStartIndex",
              "int",
              "in"
            ],
            [
              "nEndIndex",
              "int",
              "in"
            ]
          ]
        },
        {
          "name": "queryMeasures",
          "returns": "typing.List[RealRectangle2D]",
          "desc": [
            "Query the logical bounding boxes of every character in the given text string.",
            "",
            "Logical bounding boxes means the space that the font allocates for the given character, which, e.g. for a \\\".\\\", might be significantly broader than the bounds returned via XTextLayout.queryInkMeasures()."
          ],
          "raises": [],
          "args": []
        },
        {
          "name": "queryTextBounds",
          "returns": "RealRectangle2D",
          "desc": [
            "Query the overall bounding box of the text.",
            "",
            "This method is similar to XTextLayout.queryTextMeasures(), only that the overall bounds are returned by this method."
          ],
          "raises": [],
          "args": []
        },
        {
          "name": "queryTextShapes",
          "returns": "typing.List[XPolyPolygon2D]",
          "desc": [
            "Extract the polygonal shapes of the layouted text.",
            "",
            "Each glyph is represented by a separate XPolyPolygon2D in the returned sequence."
          ],
          "raises": [],
          "args": []
        },
        {
          "name": "queryVisualHighlighting",
          "returns": "XPolyPolygon2D",
          "desc": [
            "This method generates a highlight polygon.",
            "",
            "This method generates a highlighting polygon from two insertion indices. This polygon will be visually continuous, i.e. will not have non-highlighted text in between."
          ],
          "raises": [
            "com.sun.star.lang.IndexOutOfBoundsException"
          ],
          "args": [
            [
              "nStartIndex",
              "int",
              "in"
            ],
            [
              "nEndIndex",
              "int",
              "in"
            ]
          ]
        }
      ]
    }
  }
}